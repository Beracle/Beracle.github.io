---
title: MySQL 窗口函数
author: Beracle
date: 2023-11-13 22:50:00 +0800
categories: [计算机基础综合, 数据库]
tags: [数据库, MySQL, 窗口函数, 面试] 
---


## 1.窗口函数是什么

在日常工作中，经常会遇到需要在每组内排名，比如下面的业务需求：
- 排名问题：每个部门按业绩来排名
- TopN问题：找出每个部门排名前N的员工进行奖励

面对这类需求，就需要使用 sql 的高级功能窗口函数了。

![](../../assets/img/SQL/0.jpg)

窗口函数，也叫<code>OLAP</code>函数（<code>Online Anallytical Processing</code>，联机分析处理），可以对数据库数据进行实时分析处理。

窗口其实是指一个记录集合，而窗口函数则是在满足某些条件的记录集合上执行指定的函数方法。在日常工作中比较常见的例子比如求学生的单科成绩排名、求前三名等等之类的。

窗口函数的基本语法如下：
```sql
<窗口函数> OVER ( PARTITION BY <用于分组的列名> ORDER BY <用于排序的列名> )
```
那么语法中的<窗口函数>都有哪些呢？<code><窗口函数></code>的位置，可以放以下两种函数：

1. 像一些聚合函数如<code>SUM()</code>、<code>AVG()</code>、<code>COUNT()</code>、<code>MAX()</code>与<code>MIN()</code>等等
2. 以及专用的窗口函数<code>RANK()</code>、<code>DENSE_RANK()</code>与<code>ROW_NUMBER()</code>等等

因为窗口函数是对<code>where</code>或者<code>group by</code>子句处理后的结果进行操作，所以窗口函数原则上只能写在<code>select</code>子句中。

## 2.排序函数

就是进行排序操作，显示排名。<code>RANK()</code>、<code>DENSE_RANK()</code>与<code>ROW_NUMBER()</code>。
```sql
SELECT *,
       RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS RANK_排名,
       DENSE_RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS DENSE_RANK_排名,
       ROW_NUMBER() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS ROW_NUMBER_排名
FROM 成绩单
```

![](../../assets/img/SQL/1.png)

| 函数 | 说明 |
| ---- | ---- |
| RANK | 根据排序字段为每个分组中的每一行分配一个序号。排名值相同时，序号相同，但序号中存在间隙，例如：1、1、1、4、5 |
| DENSE_RANK | 根据排序字段为每个分组中的每一行分配一个序号。排名值相同时，序号相同，序号中没有间隙，例如：1、1、1、2、3 |
| ROW_NUMBER | 为表中的每一行分配一个序号，可以指定分组（也可以不指定）及排序字段（连续且不重复） |

我们要获取各科目排名第一的学生及得分，就可以再加个条件判断即可，需要注意这里用到了子查询。
```sql
SELECT * 
FROM ( SELECT *, 
              DENSE_RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS DENSE_RANK_排名 FROM 成绩单 
              ) 
WHERE DENSE_RANK_排名 = 1;
```

![](../../assets/img/SQL/2.png)

另外还有个<code>NTILE(n)</code>将分区中的有序数据分为 n 个等级，记录等级数。<code>NTILE(n)</code>在数据分析中应用较多，比如由于数据量大，需要将数据平均分配到 n 个并行的进程分别计算，此时就可以用<code>NTILE(n)</code>对数据进行分组（由于记录数不一定被 n 整除，所以数据不一定完全平均），然后将不同桶号的数据再分配。

比如按照学号分区得分排序进行分2个等级。
```sql
SELECT *,
       NTILE(2) OVER ( PARTITION BY 学号 ORDER BY 得分 DESC ) AS NTILE_
FROM 成绩单
```

![](../../assets/img/SQL/3.png)

窗口函数具备了我们之前学过的<code>group by</code>子句分组的功能和<code>order by</code>子句排序的功能。那么，为什么还要用窗口函数呢？

这是因为，<code>group by</code>分组汇总后改变了表的行数，一行只有一个类别。而<code>partiition by</code>和<code>rank</code>函数不会减少原表中的行数。

返回窗口中第N个EXPR的值，EXPR可以是表达式，也可以是列名，使用<code>NTH_VALUE()</code>函数。
```sql
NTH_VALUE(EXPR, N)
```

## 3.分布函数

分布函数有两个：<code>PERCENT_RANK()</code>和<code>CUME_DIST()</code>
<code>PERCENT_RANK()</code>的用途是每行按照公式<code>(rank-1) / (rows-1)</code>进行计算。其中，rank为<code>RANK()</code>函数产生的序号，rows为当前窗口的记录总行数。
```sql
SELECT *,
       RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC) AS RANK_排名 ,
       PERCENT_RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC) AS PERCENT_RANK_
FROM 成绩单
```

![](../../assets/img/SQL/4.png)

<code>CUME_DIST()</code>的用途是分组内小于、等于当前rank值的行数 / 分组内总行数。

查询小于等于当前成绩的比例。
```sql
SELECT *,
       RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC) AS RANK_排名 ,
       CUME_DIST() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC) AS CUME_DIST_
FROM 成绩单
```

![](../../assets/img/SQL/5.png)

可以看到，数学科目中有0.5也就是50%的朋友得分120，超过66.66%的学生成绩在118分及以上。

## 4.前后函数

查询当前行指定字段往 **前** N行数据：<code>LAG()</code>
查询当前行指定字段往 **后** N行数据：<code>LEAD()</code>
<code>LEAD()</code>和<code>LAG()</code>主要用于将某个时间段与给定指标的前一个时间段进行比较，比如：
- 获得每年销售额与上一年销售额之间的差值
- 获得每月注册/转换/网站访问次数的增量
- 按月比较用户流失率

前 N 行<code>LAG(expr[,N[,default]])</code>。比如我们看各科目同学每个人往前 3 名的同学得分。
```sql
SELECT *,
       RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC) AS RANK_排名 ,
       LAG(得分, 3) OVER ( PARTITION BY 科目 ORDER BY 得分 DESC) AS LAG_
FROM 成绩单
```
![](../../assets/img/SQL/6.png)

可以看到，各科目前三行都是NULL空值，这是因为前三行不存在它们往前3行的值。rank 4 的前3是 rank 1，对应得分是120。

这个可以用于进行一些诸如环比的情况，在这里我们可以计算当前同学与前1名同学得分差值，操作如下：

```sql
SELECT *, LAG_ - 得分 
FROM (
    SELECT *,
           RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS RANK_排名,
           LAG(得分, 1 ) OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS LAG_ 
    FROM 成绩单 
 )
 ```
 
 ![](../../assets/img/SQL/7.png)

 
## 5.首尾函数

查询指定字段第一或最后的数据<code>FIRST_VALUE(expr)</code>和<code>LAST_VALUE(expr)</code>。
 
查询各科目得分第1的分值。

```sql
SELECT *,
       RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS RANK_排名,
       FIRST_VALUE(得分) OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS FIRST_VALUE_得分 
FROM 成绩单
```

 ![](../../assets/img/SQL/8.png)

 我们可以计算各个同学与第1名的差距（上面前后函数部分介绍了和前1名的差距）。
```sql
SELECT *, FIRST_VALUE_得分 - 得分 
FROM (
       SELECT *,
              RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS RANK_排名,
              FIRST_VALUE(得分) OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS FIRST_VALUE_得分 
       FROM 成绩单 
       ) 
```

![](../../assets/img/SQL/9.png)

<code>LAST_VALUE(expr)</code>就是最后 1 名了，这里不再赘述。
另外还有<code>NTH_VALUE(expr, n)</code>查询指定字段有序行的第n的值。比如查询排名第4的数据。
```sql
SELECT *,
       RANK() OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS RANK_排名,
       NTH_VALUE(得分,4) OVER ( PARTITION BY 科目 ORDER BY 得分 DESC ) AS NTH_VALUE_得分 
FROM 成绩单
```

![](../../assets/img/SQL/10.png)

## 6.聚合函数

在窗口中每条记录动态地应用聚合函数<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>、<code>MIN()</code>、<code>COUNT()</code>，可以动态计算在指定的窗口内的各种聚合函数值。
<code>AVG()</code>在窗口函数中非常强大，因为它可以计算一段时间内的移动平均值。移动平均线是一种简单但有效的短期预测值的方法。比如
- 获取每周销售额的总体趋势
- 获取每周转换或网站访问的总体趋势

例：获取转化次数的 10 天移动平均值
```sql
SELECT Date, dailyConversions, 
       AVG(dailyConversions) OVER (ORDER BY Date ROWS 10 PRECEDING) AS 10_dayMovingAverage
FROM conversions
```

## 7.滑动窗口

### 7.1 PRECEDING
```sql
SELECT product_id, product_name, sale_price,
       AVG(sale_price) OVER ( ORDER BY product_id ROWS 2 PRECEDING) AS moving_avg
FROM Product
```
![](../../assets/img/SQL/11.png)

<code>Rows 2 preceding</code>中文的意思是之前的两行，<code>preceding</code>可以把它理解为不含当前行情况下截止到之前几行。根据上图可以看出在每一行，都会求出当前行附近的3行(当前行+附近2行)数据的平均值，这种方法也叫作**移动平均**。

### 7.2 FOLLOWING
<code>Rows 2 following</code>中文意思是之后的两行，跟<code>preceding</code>正好相反，<code>preceding</code>是向前，<code>following</code>是向后。

![](../../assets/img/SQL/12.png)

### 7.3 PRECEDING和FOLLOWING结合
```sql
SELECT product_id, product_name, sale_price,
       AVG(sale_price) OVER (ORDER BY product_id ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS moving_avg
FROM Product
```

![](../../assets/img/SQL/13.png)

从以上的运行结果可以看出是把每一行（当前行）的前一行和后一行作为汇总的依据。

## 8.窗口函数实战

1.假设有一张含两列(用户id、登陆日期)的表，查询每个用户连续登陆的天数、最早登录时间、最晚登录时间和登录次数。
- 首先要对数据进行去重，防止同一个用户一天之内出现连续登录的情况；
- 假如一个用户是连续登录的话，用<code>login_time - 窗口函数的排序</code>后得到的日期应该是一样的，连续登录的用户前后之间的时间差就是一个差值为1的等差数列；

第一步，先用<code>row_number()</code>函数排序，然后用登录日期减去排名，得到辅助列日期，如果辅助列日期是相同的话，证明用户是连续登录。
```sql
select a.user_id, a.date, a.排序, date_sub(a.date, interval a.排序 day) as 辅助列
from (
       select user_id, date(login_time) as date,
              row_number() over (partition by user_id order by login_time) as 排序 
       from user_login
) as a
```

![](../../assets/img/SQL/14.png)

第二步，用user_id和辅助列作为分组依据，分到一组的就是连续登录的用户。在每一组中最小的日期就是最早的登陆日期，最大的日期就是最近的登陆日期，对每个组内的用户进行计数就是用户连续登录的天数。
```sql
select b.user_id,
       max(b.date) as 最近登陆日期,
       min(b.date) as 最早登陆日期,
       count(b.date) as 登陆次数
from (
       select distinct a.user_id, a.date, a.排序, date_sub(a.date, interval a.排序 day) as 辅助列
       from (
              select user_id, date(login_time) as date,
                     row_number() over (partition by user_id order by login_time) as 排序 
              from user_login
       ) as a
) as b
group by b.user_id, b.'辅助列'
```

![](../../assets/img/SQL/15.png")

若求解每个用户的最大登录天数。其实可以在以上的查询结果为基础，利用聚合函数就可以求出最大的登录天数问题。假如求解连续登录5天的用户，除了可以使用上述的方法，还可以使用<code>lead</code>函数进行窗口偏移来进行求解。



示例：数据还是上题中的数据，求解连续登录五天的用户。

第一步，用<code>lead</code>函数进行窗口偏移，查找每个用户5天后的登陆日期是多少，如果是空值，说明他没有登录。
```sql
select distinct user_id,
       date(login_time) as 日期,
       lead(date(login_time),4) over (partition by user_id order by login_time) as 第五次登陆日期
from user_login
```
在<code>lead</code>函数里，为何偏移行数的参数设置为4而不是5呢，这是因为求解的是连续登录5天的用户，包括当前行在内一共是5行，所以应该向下偏移4行。

![](../../assets/img/SQL/16.png)

第二步，用<code>datediff</code>函数计算<code>(第五次登陆日期－日期) + 1</code>是否等于5，等于5证明用户是连续5天登录的，为空值或者大于5都不是5天连续登陆的用户。

第三步，用where设定条件，差值大于等于5筛选连续登录的用户。
```sql
with b as (
       select user_id, a.日期, a.第五次登陆日期, datediff(a.第五次登录日期, a.日期) + 1 as 相差天数
       from (
              select distinct user_id,
                     date(login_time) as 日期,
                     lead(date(login_time),4) over (partition by user_id order by login_time) as 第五次登陆日期
              from user_login
       ) as a
)
select distinct b.user_id
from b
where b.'相差天数' = 5
```
用<code>lead</code>函数求解连续登录的问题还有一个好处就是当表中的数据不在同一个月份时也可以完美的解决，不用再考虑月份带来的影响。